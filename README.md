# 浏览器工作原理
- [浏览器工作原理](#浏览器工作原理)
  - [1. 浏览器的多进程架构](#1-浏览器的多进程架构)
  - [2. JS执行机制和V8](#2-js执行机制和v8)
    - [2.1. 栈和堆](#21-栈和堆)
    - [2.2. 垃圾回收](#22-垃圾回收)
      - [2.2.1. 调用栈中的数据是如何回收的](#221-调用栈中的数据是如何回收的)
      - [2.2.2. 堆中的数据是如何回收的](#222-堆中的数据是如何回收的)
    - [2.3. 编译器和解释器：V8是如何执行一段JavaScript代码的](#23-编译器和解释器v8是如何执行一段javascript代码的)
      - [2.3.1. 编译器和解释器](#231-编译器和解释器)
      - [2.3.2. V8 是如何执行一段 JavaScript 代码的](#232-v8-是如何执行一段-javascript-代码的)
    - [2.4. JavaScript 的性能优化](#24-javascript-的性能优化)
  - [3. 循环系统](#3-循环系统)
    - [3.1. 消息队列中的任务类型](#31-消息队列中的任务类型)
    - [3.2. 如何安全退出](#32-如何安全退出)
    - [3.3. 如何处理高优先级的任务](#33-如何处理高优先级的任务)
    - [3.4. 如何解决单个任务执行时长过久的问题](#34-如何解决单个任务执行时长过久的问题)
    - [3.5. 宏任务](#35-宏任务)
    - [3.6. 微任务](#36-微任务)
  - [4. 网络](#4-网络)
    - [4.1. 浏览器端发起 HTTP 请求流程](#41-浏览器端发起-http-请求流程)
    - [4.2. TCP的三次握手和四次挥手](#42-tcp的三次握手和四次挥手)
    - [4.3. http1](#43-http1)
    - [4.4. http2](#44-http2)
    - [4.5. http3](#45-http3)
    - [4.6. https](#46-https)
  - [5. 页面渲染过程](#5-页面渲染过程)
    - [5.1. 构建 DOM 树](#51-构建-dom-树)
    - [5.2. 样式计算（Recalculate Style）](#52-样式计算recalculate-style)
    - [5.3. 布局阶段](#53-布局阶段)
    - [5.4. 分层](#54-分层)
    - [5.5. 图层绘制](#55-图层绘制)
    - [5.6. 栅格化（raster）操作](#56-栅格化raster操作)
    - [5.5. 合成和显示](#55-合成和显示)
  - [6. 浏览器安全](#6-浏览器安全)
  - [7. 参考资料](#7-参考资料)

## 1. 浏览器的多进程架构

![Chrome 进程架构](images/browserui.png)  

从图中可以看出， Chrome 浏览器包括：1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程。

1. 浏览器进程。主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。
2. 渲染进程。核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。
3. GPU 进程。其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。
4. 网络进程。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。插件进程。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。  

下图是一个打开了 1 个页面的进程情况

![Chrome 任务管理器](images/chrome-gpu.png)  

在 2016 年，Chrome 官方团队使用“面向服务的架构”（Services Oriented Architecture，简称 SOA）的思想设计了新的 Chrome 架构。也就是说 Chrome 整体架构会朝向现代操作系统所采用的“面向服务的架构” 方向发展，原来的各种模块会被重构成独立的服务（Service），每个服务（Service）都可以在独立的进程中运行，访问服务（Service）必须使用定义好的接口，通过 IPC 来通信，从而构建一个更内聚、松耦合、易于维护和扩展的系统，更好实现 Chrome 简单、稳定、高速、安全的目标。  

![Chrome“面向服务的架构”的进程模型图](images/soa.png)

## 2. JS执行机制和V8

### 2.1. 栈和堆

原始类型的数据是存放在栈中，引用类型的数据是存放在堆中的。堆中的数据是通过引用和变量关联起来的。也就是说，JavaScript 的变量是没有数据类型的，值才有数据类型，变量可以随时持有任何类型的数据。  

因为 JavaScript 引擎需要用栈来维护程序执行期间上下文的状态，如果栈空间大了话，所有的数据都存放在栈空间里面，那么会影响到上下文切换的效率，进而又影响到整个程序的执行效率。  

JavaScript 引擎正是利用栈的这种结构来管理执行上下文的。在执行上下文创建好后，JavaScript 引擎会将执行上下文压入栈中，通常把这种用来管理执行上下文的栈称为执行上下文栈，又称调用栈。  

### 2.2. 垃圾回收

使用的是自动垃圾回收的策略，如 JavaScript、Java、Python 等语言，产生的垃圾数据是由垃圾回收器来释放的，并不需要手动通过代码来释放。  

#### 2.2.1. 调用栈中的数据是如何回收的

原始类型的数据被分配到栈中，引用类型的数据会被分配到堆中。当 foo 函数执行结束之后，foo 函数的执行上下文会从堆中被销毁掉

```js

function foo(){
    var a = 1
    var b = {name:"AA"}
    function showName(){
      var c = 2
      var d = {name:"BB"}
    }
    showName()
}
foo()
```

如果执行到 showName 函数时，那么 JavaScript 引擎会创建 showName 函数的执行上下文，并将 showName 函数的执行上下文压入到调用栈中，最终执行到 showName 函数时，与此同时，还有一个记录当前执行状态的指针（称为 ESP），指向调用栈中 showName 函数的执行上下文，表示当前正在执行 showName 函数。  

当 showName 函数执行完成之后，函数执行流程就进入了 foo 函数，那这时就需要销毁 showName 函数的执行上下文了。JavaScript 会将 ESP 下移到 foo 函数的执行上下文，这个下移操作就是销毁 showName 函数执行上下文的过程。  

![stack](images/stack.jpg)

#### 2.2.2. 堆中的数据是如何回收的

当上面那段代码的 foo 函数执行结束之后，ESP 应该是指向全局执行上下文的，那这样的话，showName 函数和 foo 函数的执行上下文就处于无效状态了，不过保存在堆中的两个对象依然占用着空间, 要回收堆中的垃圾数据，就需要用到 JavaScript 中的垃圾回收器了。  

代际假说（The Generational Hypothesis）的内容，这是垃圾回收领域中一个重要的术语，后续垃圾回收的策略都是建立在该假说的基础之上的，所以很是重要。代际假说有以下两个特点：  

- 第一个是大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问；  
- 第二个是不死的对象，会活得更久。  

在 V8 中会把堆分为新生代和老生代两个区域，新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象。  

新生区通常只支持 1～8M 的容量，而老生区支持的容量就大很多了。对于这两块区域，V8 分别使用两个不同的垃圾回收器，以便更高效地实施垃圾回收。  

- 副垃圾回收器，主要负责新生代的垃圾回收。  
- 主垃圾回收器，主要负责老生代的垃圾回收。  

> 垃圾回收器的工作流程  

 V8 把堆分成两个区域——新生代和老生代，并分别使用两个不同的垃圾回收器。其实不论什么类型的垃圾回收器，它们都有一套共同的执行流程。  

- 第一步是标记空间中活动对象和非活动对象。所谓活动对象就是还在使用的对象，非活动对象就是可以进行垃圾回收的对象。
- 第二步是回收非活动对象所占据的内存。其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。
- 第三步是做内存整理。一般来说，频繁回收对象后，内存中就会存在大量不连续空间，我们把这些不连续的内存空间称为内存碎片。当内存中出现了大量的内存碎片之后，如果需要分配较大连续内存的时候，就有可能出现内存不足的情况。所以最后一步需要整理这些内存碎片，但这步其实是可选的，因为有的垃圾回收器不会产生内存碎片，比如副垃圾回收器。  

> **副垃圾回收器**

副垃圾回收器主要负责新生区的垃圾回收。而通常情况下，大多数小的对象都会被分配到新生区，所以说这个区域虽然不大，但是垃圾回收还是比较频繁的。  

新生代中用 Scavenge 算法来处理。所谓 Scavenge 算法，是把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域，如下图所示：

![scavenge](images/scavenge.png)

新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。  
在垃圾回收过程中，首先要对对象区域中的垃圾做标记；标记完成之后，就进入垃圾清理阶段，副垃圾回收器会把这些存活的对象复制到空闲区域中，同时它还会把这些对象有序地排列起来，所以这个复制过程，也就相当于完成了内存整理操作，复制后空闲区域就没有内存碎片了。  

完成复制后，对象区域与空闲区域进行角色翻转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。这样就完成了垃圾对象的回收操作，同时这种角色翻转的操作还能让新生代中的这两块区域无限重复使用下去。  

由于新生代中采用的 Scavenge 算法，所以每次执行清理操作时，都需要将存活的对象从对象区域复制到空闲区域。但复制操作需要时间成本，如果新生区空间设置得太大了，那么每次清理的时间就会过久，所以为了执行效率，一般新生区的空间会被设置得比较小。  

也正是因为新生区的空间不大，所以很容易被存活的对象装满整个区域。为了解决这个问题，JavaScript 引擎采用了对象晋升策略，也就是经过两次垃圾回收依然还存活的对象，会被移动到老生区中。  

> **主垃圾回收器**  

主垃圾回收器主要负责老生区中的垃圾回收。除了新生区中晋升的对象，一些大的对象会直接被分配到老生区。因此老生区中的对象有两个特点，一个是对象占用空间大，另一个是对象存活时间长。  

由于老生区的对象比较大，若要在老生区中使用 Scavenge 算法进行垃圾回收，复制这些大的对象将会花费比较多的时间，从而导致回收执行效率不高，同时还会浪费一半的空间。因而，主垃圾回收器是采用标记 - 清除（Mark-Sweep）的算法进行垃圾回收的。  

- 首先是标记过程阶段。标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据。

- 垃圾的清除过程。它和副垃圾回收器的垃圾清除过程完全不同，你可以理解这个过程是清除掉红色标记数据的过程.  

![mark-sweep](images/mark-sweep.png)

不过对一块内存多次执行标记 - 清除算法后，会产生大量不连续的内存碎片。而碎片过多会导致大对象无法分配到足够的连续内存，于是又产生了另外一种算法——标记 - 整理（Mark-Compact），这个标记过程仍然与标记 - 清除算法里的是一样的，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

![mark-compact](images/mark-compact.png)

> **全停顿**  

由于 JavaScript 是运行在主线程之上的，一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做全停顿（Stop-The-World）。  

为了降低老生代的垃圾回收而造成的卡顿，V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为增量标记（Incremental Marking）算法。  

![incremental](images/incremental.png)

使用增量标记算法，可以把一个完整的垃圾回收任务拆分为很多小的任务，这些小的任务执行时间比较短，可以穿插在其他的 JavaScript 任务中间执行，这样当执行动画效果时，就不会让用户因为垃圾回收任务而感受到页面的卡顿了。  

### 2.3. 编译器和解释器：V8是如何执行一段JavaScript代码的

#### 2.3.1. 编译器和解释器

按语言的执行流程，可以把语言划分为编译型语言和解释型语言。  

编译型语言在程序执行之前，需要经过编译器的编译过程，并且编译之后会直接保留机器能读懂的二进制文件，这样每次运行程序时，都可以直接运行该二进制文件，而不需要再次重新编译了。  
比如 C/C++、GO 等都是编译型语言。而由解释型语言编写的程序，在每次运行时都需要通过解释器对程序进行动态解释和执行。比如 Python、JavaScript 等都属于解释型语言。  

![translate-code](images/translate-code.png)

#### 2.3.2. V8 是如何执行一段 JavaScript 代码的

![v8](images/v8.png)

> **1. 生成抽象语法树（AST）和执行上下文**  

代码经过[javascript-ast](https://resources.jointjs.com/demos/javascript-ast)处理后，生成的 AST 结构.  

AST 是非常重要的一种数据结构，在很多项目中有着广泛的应用。其中最著名的一个项目是 Babel。Babel 是一个被广泛使用的代码转码器，可以将 ES6 代码转为 ES5 代码，这意味着你可以现在就用 ES6 编写程序，而不用担心现有环境是否支持 ES6。Babel 的工作原理就是先将 ES6 源码转换为 AST，然后再将 ES6 语法的 AST 转换为 ES5 语法的 AST，最后利用 ES5 的 AST 生成 JavaScript 源代码。  

除了 Babel 外，还有 ESLint 也使用 AST。ESLint 是一个用来检查 JavaScript 编写规范的插件，其检测流程也是需要将源码转换为 AST，然后再利用 AST 来检查代码规范化的问题。  

生成 AST 需要经过两个阶段: 先分词，再解析  

- 第一阶段是分词（tokenize），又称为词法分析，其作用是将一行行的源码拆解成一个个 token。所谓 token，指的是语法上不可能再分的、最小的单个字符或字符串。你可以参考下图来更好地理解什么 token。  

- 第二阶段是解析（parse），又称为语法分析，其作用是将上一步生成的 token 数据，根据语法规则转为 AST。如果源码符合语法规则，这一步就会顺利完成。但如果源码存在语法错误，这一步就会终止，并抛出一个“语法错误”。  

> **2. 生成字节码**  

解释器Ignition 会根据 AST 生成字节码，并解释执行字节码。  

其实一开始 V8 并没有字节码，而是直接将 AST 转换为机器码，由于执行机器码的效率是非常高效的，所以这种方式在发布后的一段时间内运行效果是非常好的。但是随着 Chrome 在手机上的广泛普及，特别是运行在 512M 内存的手机上，内存占用问题也暴露出来了，因为 V8 需要消耗大量的内存来存放转换后的机器码。为了解决内存占用问题，V8 团队大幅重构了引擎架构，引入字节码，并且抛弃了之前的编译器，最终花了将进四年的时间，实现了现在的这套架构。  

字节码就是介于 AST 和机器码之间的一种代码。但是与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码后才能执行。  

字节码和机器码占用空间对比:机器码所占用的空间远远超过了字节码，所以使用字节码可以减少系统的内存使用。  

![byteocode](images/bytecode.png)

> **3. 执行代码**

1. 如果有一段第一次执行的字节码，解释器 Ignition 会逐条解释执行。在 Ignition 执行字节码的过程中，如果发现有热点代码（HotSpot），比如一段代码被重复执行多次，这种就称为热点代码，那么后台的编译器 TurboFan 就会把该段热点的字节码编译为高效的机器码，然后当再次执行这段被优化的代码时，只需要执行编译后的机器码就可以了，这样就大大提升了代码的执行效率。  

2. 即时编译（JIT）,指解释器 Ignition 在解释执行字节码的同时，收集代码信息，当它发现某一部分代码变热了之后，TurboFan 编译器把热点的字节码转换为机器码，并把转换后的机器码保存起来，以备下次使用。  

![JIT](images/JIT.png)

### 2.4. JavaScript 的性能优化

1. 提升单次脚本的执行速度，避免 JavaScript 的长任务霸占主线程，这样可以使得页面快速响应交互；
2. 避免大的内联脚本，因为在解析 HTML 的过程中，解析和编译也会占用主线程；
3. 减少 JavaScript 文件的容量，因为更小的文件会提升下载速度，并且占用更低的内存。

## 3. 循环系统

![progress](images/progress.png)

渲染进程专门有一个 IO 线程用来接收其他进程传进来的消息，接收到消息之后，会将这些消息组装成任务发送给渲染主线程.  

### 3.1. 消息队列中的任务类型

内部消息类型: 如输入事件（鼠标滚动、点击、移动）、微任务、文件读写、WebSocket、JavaScript 定时器等等。  

与页面相关的事件: 如 JavaScript 执行、解析 DOM、样式计算、布局计算、CSS 动画等。  

### 3.2. 如何安全退出

当页面主线程执行完成之后，又该如何保证页面主线程能够安全退出呢？Chrome 是这样解决的，确定要退出当前页面时，页面主线程会设置一个退出标志的变量，在每次执行完一个任务时，判断是否有设置退出标志。  

```c
TaskQueue task_queue；
void ProcessTask();
bool keep_running = true;
void MainThread(){
  for(;;){
    Task task = task_queue.takeTask();
    ProcessTask(task);
    if(!keep_running) //如果设置了退出标志，那么直接退出线程循环
        break; 
  }
}
```

### 3.3. 如何处理高优先级的任务

如果 DOM 发生变化，采用同步通知的方式，会影响当前任务的执行效率；如果采用异步方式，又会影响到监控的实时性。那该如何权衡效率和实时性呢？针对这种情况，微任务就应用而生了.  

通常我们把消息队列中的任务称为宏任务，每个宏任务中都包含了一个微任务队列，在执行宏任务的过程中，如果 DOM 有变化，那么就会将该变化添加到微任务列表中，这样就不会影响到宏任务的继续执行，因此也就解决了执行效率的问题。  

等宏任务中的主要功能都直接完成之后，这时候，渲染引擎并不着急去执行下一个宏任务，而是执行当前宏任务中的微任务，因为 DOM 变化的事件都保存在这些微任务队列中，这样也就解决了实时性问题。  

### 3.4. 如何解决单个任务执行时长过久的问题

因为所有的任务都是在单线程中执行的，所以每次只能执行一个任务，而其他任务就都处于等待状态。如果其中一个任务执行时间过久，那么下一个任务就要等待很长时间。  

如果在执行动画过程中，其中有个 JavaScript 任务因执行时间过久，占用了动画单帧的时间，这样会给用户制造了卡顿的感觉，这当然是极不好的用户体验。针对这种情况，JavaScript 可以通过回调功能来规避这种问题，也就是让要执行的 JavaScript 任务滞后执行。  

把异步回调函数封装成一个宏任务，添加到消息队列尾部，当循环系统执行到该任务的时候执行回调函数。setTimeout 和 XMLHttpRequest 的回调函数都是通过这种方式来实现的。  

### 3.5. 宏任务

- 渲染事件（如解析 DOM、计算布局、绘制）；
- 用户交互事件（如鼠标点击、滚动页面、放大缩小等）；
- JavaScript 脚本执行事件；
- 网络请求完成、文件读写完成事件。

消息队列中宏任务的执行过程:

1. 先从多个消息队列中选出一个最老的任务，这个任务称为 oldestTask；
2. 然后循环系统记录任务开始执行的时间，并把这个 oldestTask 设置为当前正在执行的任务；
3. 当任务执行完成之后，删除当前正在执行的任务，并从对应的消息队列中删除掉这个 oldestTask；
4. 最后统计执行完成的时长等信息。

### 3.6. 微任务

微任务就是一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。  

产生微任务有两种方式:

1. 第一种方式是使用 MutationObserver 监控某个 DOM 节点，然后再通过 JavaScript 来修改这个节点，或者为这个节点添加、删除部分子节点，当 DOM 节点发生变化时，就会产生 DOM 变化记录的微任务。
2. 第二种方式是使用 Promise，当调用 Promise.resolve() 或者 Promise.reject() 的时候，也会产生微任务。

在当前宏任务中的 JavaScript 快执行完成时，也就在 JavaScript 引擎准备退出全局执行上下文并清空调用栈的时候，JavaScript 引擎会检查全局执行上下文中的微任务队列，然后按照顺序执行队列中的微任务。  

如果在执行微任务的过程中，产生了新的微任务，同样会将该微任务添加到微任务队列中，V8 引擎一直循环执行微任务队列中的任务，直到队列为空才算执行结束。也就是说在执行微任务过程中产生的新的微任务并不会推迟到下个宏任务中执行，而是在当前的宏任务中继续执行。  

- 微任务和宏任务是绑定的，每个宏任务在执行时，会创建自己的微任务队列。
- 微任务的执行时长会影响到当前宏任务的时长。比如一个宏任务在执行过程中，产生了 100 个微任务，执行每个微任务的时间是 10 毫秒，那么执行这 100 个微任务的时间就是 1000 毫秒，也可以说这 100 个微任务让宏任务的执行时间延长了 1000 毫秒。所以你在写代码的时候一定要注意控制微任务的执行时长。
- 在一个宏任务中，分别创建一个用于回调的宏任务和微任务，无论什么情况下，微任务都早于宏任务执行。

> **监听 DOM 变化方法**  

Mutation Event 由于同步调用 JavaScript 而造成的性能问题，从 DOM4 开始，推荐使用 MutationObserver 来代替 Mutation Event。MutationObserver API 可以用来监视 DOM 的变化，包括属性的变化、节点的增减、内容的变化等。  

1. MutationObserver 将响应函数改成异步调用，可以不用在每次 DOM 变化都触发异步调用，而是等多次 DOM 变化后，一次触发异步调用，并且还会使用一个数据结构来记录这期间所有的 DOM 变化。这样即使频繁地操纵 DOM，也不会对性能造成太大的影响。
2. 在每次 DOM 节点发生变化的时候，渲染引擎将变化记录封装成微任务，并将微任务添加进当前的微任务队列中。这样当执行到检查点的时候，V8 引擎就会按照顺序执行微任务了。  

MutationObserver 采用了“异步 + 微任务”的策略。

- 通过异步操作解决了同步操作的性能问题；
- 通过微任务解决了实时性的问题。  

## 4. 网络

七层网络协议

![net](images/net.png)

五层网络协议

![net](images/net-1.png)

> **1. 应用层**  

在操作系统之上，直接使用软件获取相关的网络服务，一般协议由提供相关服务的软件实现。  

1）WEB服务: WEB服务一般由浏览器提供，其包含了3个关键技术  

1.1）HTTP协议：超文本传输协议，规定了文本传输的格式，默认端口【80】,底下采用了TCP协议传输  
1.2）HTML：超文本标记语言，只是一门语言，用来标记文字图片等该何如显示  
1.3）URL：统一资源定位符，规定了网络上资源的标记方式  

2）DNS服务: 用于解析域名的IP地址，默认使用端口【53】,传输层采用UDP协议实现。  

解析方式有递归解析和迭代解析，使用本地缓存和路由器缓存提高效率。  

3）FTP文件传输服务: 用于实现不同网络主机间的文件传输需求，使用FTP协议实现，默认端口【20】（用于数据连接，每一个文本都需要重新建立一次连接）【21】（用于命令传输），底下采用了TCP协议传输.  
如果采用TFTP协议实现，则底下采用的是UDP协议传输，其支持的命令操作较少。  

4）电子邮件服务: 电子邮件服务一般由电子邮件相关软件实现，采用端口【25】  

邮件传输协议有两种选择，SMTP（只支持传输纯文本）, MIME（支持多媒体类型传输）  
访问邮件服务器也有两种方式，POP-3（简单上传下载），IMAP-4（可以在邮件服务器中直接对邮件进行操作）  

5）远程桌面服务: 使用TELNET协议实现，默认端口【23】, 底下使用TCP协议传输  

6）DHCP: DHCP是动态主机配置协议，用于主机的网络配置服务，可以动态的为客户端配置路由器地址，IP地址，服务器地址等。在一开始时，客户机还没有一个IP地址，需要把一个DHCP请求报文广播出去，DHCP服务器接收到请求，同样把带有配置信息的报文广播发送回去，客户机接收配置完毕后就进入了绑定状态，不再接受配置报文信息。当IP过期时，需要再次发送请求.  

7）SNMP: SNMP用于网络管理服务，用来检测统计网络流量等.  

> **2. 传输层**  

解决源主机到目的主机之间端到端的通信，主要涉及的有TCP和UDP两个协议，此层一般由操作系统负责管理和实现。  
在本层中一个套接字地址为IP地址+端口号，一个网络进程的通信标志为：传输协议+本地IP+本地端口+目的IP+目的端口。  
无论是TCP和UDP报文，都可以统一称为TPDU传输协议数据单元。  

1）端口号分配  

熟知端口号 0~2^10-1 ：服务器默认的全局端口号， 一般由系统固定分配  
注册端口号 2^10~2^12-1  和 临时端口号 2^12~2^16-1 ：这些都是用户请求时，系统给用户动态分配和回收的  

2）多路复用与多路分解  

传输层允许多个应用层使用不同的端口号同时进行消息发送。在发送端，传输层依照不同的端口号替数据进行包装递交给网络层，在接收端，传输层依照不同端口号将数据正确转交给相应的程序  

3）TCP与UDP  

传输层协议有TCP和UDP可以选择。  

TCP：面向连接和字节流，有确认机制，重发机制，流量控制，拥塞控制，建立连接需要3次握手，断开连接需要四次挥手。  
UDP：无连接，无确认机制、重传机制，开销低，速率高，可用于多播和组播.  

> **3. 网络层**  

解决的是源主机-路由器-路由器-目的主机之间的点对点传播，路由器在网络中也可以看成一个具有ip地址的主机。  

1）IP协议  

网络层的数据传输协议，对来自TCP | UDP 数据报文进一步封装和分组，转交给数据链路层。  
IP协议是无连接不可靠的，当发现分组出错或者丢失，会发送一个ICMP差错报文，但是是由上一层协议负责是否要重发。  
涉及的有：IP地址分类，子网划分，分组格式，路由转发算法，IPV6等。  

2）ARP协议  

ARP协议使用解析IP地址对应的物理地址（6字节）的。RARP则相反，是用来解析物理地址对应的IP地址的。ARP报文无需IP协议封装。  

3）NAT(网络地址转换Network Address Translation)  

当你在局域网上访问局域网内的内容时，用的是诸如172.31,192.168等局域网IP，这在公网上进行访问时，是不被允许的，因为公网上的IP是唯一的，而局域网地址在不同的局域网下却是可以重复。但是公网的地址是紧缺的，不可能为每个局域网内的用户都分配一个公网IP，这时就需要使用NAT地址转换技术了。  

当用户访问公网时，执行NAT协议的路由器就会从自己的公网IP池为用户分配一个临时的公网IP，并将用户报文中的内部地址修改成公网地址进行发送。当接收时，该路由器又会把报文中的公网地址修改回内网地址，将其传送回用户。所以，有时你会发现自己的公网IP发生了变化。  

4）ICMP  

ICMP是互联网控制报文协议，可以用来查看和控制IP分组在网络传播情况，其报文需要经过IP协议的封装。  
最常见的ping命令就是发送一条ICMP的查询报文。  

> **4. 数据链路层**  

数据链路层要讨论是数据帧（1bit）级别的传输问题。  

数据链路拥有帧同步（错误重发），差错控制（海明码和CRC纠错），流量与拥塞控制等功能。  

> **5. 物理层**  

物理层考虑是如何将采集的信号转化为二进制数据，用什么介质传输信号等等。  

| 层 | 典型设备 | 中间设备 | 数据单元 | 网络协议 |
| --- | --- | --- | --- | --- |
| 物理层 | 中继器、集线器、使用了光纤、 同轴电缆、双绞线……  | 中继器、集线器 | 数据位（bit）binary digit 二进制数据的缩写 | 无 |
| 数据链路层 | 网卡、网桥、交换机 | 网桥、交换机 | 数据帧 （Frame） | ARQ、SW、CSMA/CD、PPP、HDLC、ATM |
| 网络层 | 路由器、防火墙、多层交换机 | 路由器 | 数据包（Packet） | IP、ARP 、RARP 、ICMP 、ICMPv6、IGMP、RIP 、OSPF 、BGP |
| 传输层 | 进程和端口 | 四层路由器 | 数据段 （Segment） | TCP  UDP |
| 应用层 | 应用程序，如FTP，SMTP ，HTTP | 网关 | 报文（message） | DHCP、DNS、FTP、HTTP、POP3、SMTP 、SSH 、TELNET |

### 4.1. 浏览器端发起 HTTP 请求流程

1. 域名解析
2. 发起TCP的3次握手
3. 建立TCP连接后发起http请求
4. 服务器响应http请求，浏览器得到html代码
5. 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等）
6. 浏览器对页面进行渲染呈现给用户

> 域名解析  

1. 浏览器会检查缓存中有没有这个域名对应的解析过的IP地址，如果缓存中有，这个解析过程就将结束。浏览器缓存域名也是有限制的，不仅浏览器缓存大小有限制，而且缓存的时间也有限制，通常情况下为几分钟到几小时不等，域名被缓存的时间限制可以通过TTL(Time-To-Live)属性来设置.
2. 如果浏览器自身的缓存里面没有找到对应的条目，那么Chrome会搜索操作系统自身的DNS缓存,如果找到且没有过期则停止搜索解析到此结束.
3. 如果在系统的DNS缓存也没有找到，那么尝试读取hosts文件，看看这里面有没有该域名对应的IP地址，如果有则解析成功。
4. 如果在hosts文件中也没有找到对应的条目，浏览器就会发起一个DNS的系统调用，就会向本地配置的首选DNS服务器（一般是电信运营商提供的）发起域名解析请求。 运营商dns --> 根域名服务器 --> 顶级域名服务器 --> 域名注册商服务器. 

### 4.2. TCP的三次握手和四次挥手

> 三次握手（three-way handshaking）  

1.背景：TCP位于传输层，作用是提供可靠的字节流服务，为了准确无误地将数据送达目的地，TCP协议采纳三次握手策略。  

2.原理：  

1）发送端首先发送一个带有SYN（synchronize）标志地数据包给接收方。  
2）接收方接收后，回传一个带有SYN/ACK标志的数据包传递确认信息，表示我收到了。  
3）最后，发送方再回传一个带有ACK标志的数据包，代表我知道了，表示"握手"结束。  

![tcp](images/tcp.png)

> 四次挥手（Four-Way-Wavehand）  

1.意义：当被动方收到主动方的FIN报文通知时，它仅仅表示主动方没有数据再发送给被动方了。但未必被动方所有的数据都完整的发送给了主动方，所以被动方不会马上关闭SOCKET,它可能还需要发送一些数据给主动方后，再发送FIN报文给主动方，告诉主动方同意关闭连接，所以这里的ACK报文和FIN报文多数情况下都是分开发送的。  

2.原理：

1）第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。  

2）第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。  

3）第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。  

4）第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。  

![tcp-Wavehand](images/tcp-Wavehand.png)

### 4.3. http1



### 4.4. http2



### 4.5. http3



### 4.6. https

https协议需要到ca申请证书；http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议；http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443；http的连接很简单，是无状态的，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议。  





## 5. 页面渲染过程

构建 DOM 树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成。  

### 5.1. 构建 DOM 树

构建 DOM 树的输入内容是一个 HTML 文件，然后经由 HTML 解析器解析，最终输出树状结构的 DOM。

![dom](images/DOM.png)

### 5.2. 样式计算（Recalculate Style）

构建 DOM 树的输入内容是一个非常简单的 HTML 文件，然后经由 HTML 解析器解析，最终输出树状结构的 DOM。

1. 把 CSS 转换为浏览器能够理解的结构

CSS 样式来源主要有三种：

- 通过 link 引用的外部 CSS 文件  
- <style>标记内的 CSS
- 元素的style 属性内嵌的 CSS  

当渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构——styleSheets。  

2. 转换样式表中的属性值，使其标准化  

CSS 文本中有很多属性值，如 2em、blue、bold，这些类型数值不容易被渲染引擎理解，所以需要将所有值转换为渲染引擎容易理解的、标准化的计算值，这个过程就是属性值标准化。  

![css](images/css.png)

3. 计算出 DOM 树中每个节点的具体样式  

- 首先是 CSS 继承。CSS 继承就是每个 DOM 节点都包含有父节点的样式。

- 第二个规则是样式层叠。层叠是 CSS 的一个基本特征，它是一个定义了如何合并来自多个源的属性值的算法。

### 5.3. 布局阶段

构建布局树，浏览器大体上完成了下面这些工作：  

- 遍历 DOM 树中的所有可见节点，并把这些节点加到布局树中；  
- 而不可见的节点会被布局树忽略掉，如 head 标签下面的全部内容，再比如 body.p.span 这个元素，因为它的属性包含 dispaly:none，所以这个元素也没有被包进布局树。  

![structure](images/structure.png)

### 5.4. 分层

渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree），Chrome 的“开发者工具”，选择“Layers”标签，就可以可视化页面的分层情况。  

浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面。下面我们再来看看这些图层和布局树节点之间的关系  

![layertree](images/layertree.png)

并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。如上图中的 span 标签没有专属图层，那么它们就从属于它们的父节点图层。  

满足下面两点中任意一点的元素就可以被提升为单独的一个图层。  

> **第一点，拥有层叠上下文属性的元素会被提升为单独的一层。**  

页面是个二维平面，但是层叠上下文能够让 HTML 元素具有三维概念，这些 HTML 元素按照自身属性的优先级分布在垂直于这个二维平面的 z 轴上。定位属性的元素、定义透明属性的元素、使用 CSS 滤镜的元素等，都拥有层叠上下文属性。  

![stacking context](images/stacking-context.png)

> **第二点，需要剪裁（clip）的地方也会被创建为图层。**

把 div 的大小限定为 200 * 200 像素，而 div 里面的文字内容比较多，文字所显示的区域肯定会超出 200 * 200 的面积，这时候就产生了剪裁，渲染引擎会把裁剪文字内容的一部分用于显示在 div 区域,出现这种裁剪情况的时候，渲染引擎会为文字部分单独创建一个层，如果出现滚动条，滚动条也会被提升为单独的层。  

### 5.5. 图层绘制

渲染引擎实现图层的绘制, 会把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表。  

### 5.6. 栅格化（raster）操作

绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的合成线程来完成的。  

通常一个页面可能很大，但是用户只能看到其中的一部分，我们把用户可以看到的这个部分叫做视口（viewport）。  
在有些情况下，有的图层可以很大，比如有的页面你使用滚动条要滚动好久才能滚动到底部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。  
基于这个原因，合成线程会将图层划分为图块（tile），这些图块的大小通常是 256x256 或者 512x512。  

合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。而图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的。  

栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。  

![raster](images/raster.png)

### 5.5. 合成和显示

一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。  

浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。到这里，经过这一系列的阶段，编写好的 HTML、CSS、JavaScript 等文件，经过浏览器就会显示出漂亮的页面了。  

![render](images/render.png)

一个完整的渲染流程大致可总结为如下：

1. 渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构。
2. 渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。
3. 创建布局树，并计算元素的布局信息。
4. 对布局树进行分层，并生成分层树。
5. 为每个图层生成绘制列表，并将其提交到合成线程。
6. 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。
7. 合成线程发送绘制图块命令 DrawQuad 给浏览器进程。
8. 浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上.

## 6. 浏览器安全



## 7. 参考资料

https://developers.google.com/web/updates/2018/07/page-lifecycle-api  
https://developers.google.com/web/updates/2018/09/inside-browser-part1  
https://developers.google.com/web/updates/2018/09/inside-browser-part2  
https://developers.google.com/web/updates/2018/09/inside-browser-part3  
https://developers.google.com/web/updates/2018/09/inside-browser-part4  
https://time.geekbang.org/column/article/113513  
